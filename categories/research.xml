<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Senthil Kumaran's thoughts. (Posts about research)</title><link>http://www.xtoinfinity.com/</link><description></description><atom:link href="http://www.xtoinfinity.com/categories/research.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><lastBuildDate>Tue, 27 Jun 2017 14:37:39 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Deep Learner Playing Breakout</title><link>http://www.xtoinfinity.com/posts/deep-learner-playing-breakout.html</link><dc:creator>Senthil Kumaran</dc:creator><description>&lt;div&gt;&lt;p&gt;Let's first watch this video&lt;/p&gt;
&lt;div class="youtube-video align-center"&gt;
&lt;iframe width="425" height="344" src="https://www.youtube.com/embed/qINUIONARkE?rel=0&amp;amp;hd=1&amp;amp;wmode=transparent"&gt;&lt;/iframe&gt;
&lt;/div&gt;&lt;p&gt;In this video, I just gave the program a game and it learned to play by itself. No, I did
not code the player, that would have been so traditional. Here the player, the computer, the
program, actually learns to play by itself by just playing the game! It does not need me.&lt;/p&gt;
&lt;p&gt;I recorded this video for experiencing how a Deep learning algorithm actually works. And as you
can notice, it works amazingly! Deep learning is subset Artificial Intelligence that tries to show
"intelligent behavior" by using something similar to (neural networks) human brains wiring.
It uses mathematics, that we think, human brains internally use to exhibit rational thinking.&lt;/p&gt;
&lt;p&gt;The results of these have been amazing. From beating go games (&lt;a class="reference external" href="https://blog.codinghorror.com/thanks-for-ruining-another-game-forever-computers/"&gt;Thanks For Ruining Another
Game Forever, Computers&lt;/a&gt;) , to making self-driving cars a possibility. The above video
should give some idea that self-driving cars can learn about hurdles and try to navigate by itself.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;How to setup your system for Deep Learning Experiment ?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I wish, you will be excited to replicate this experiment. If you are interested, here is how I setup.&lt;/p&gt;
&lt;p&gt;1. Rent a GPU Instance from AWS or Azure. Right now, we need GPUS. They are very costly, but the deep learning frameworks
are not optimized for CPUs. I spent multiple weeks of uptime on CPU without any results. Go for GPU. AWS Has it.&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;Setup &lt;a class="reference external" href="http://tleyden.github.io/blog/2014/10/25/cuda-6-dot-5-on-aws-gpu-instance-running-ubuntu-14-dot-04/"&gt;Ubuntu 14.04 with proper NVIDIA&lt;/a&gt; drivers.&lt;/li&gt;
&lt;li&gt;Install X11 and Window Manager. It wont be fun otherwise.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="literal-block"&gt;
sudo apt-get install xubuntu-desktop xfce
&lt;/pre&gt;
&lt;p&gt;4. Setup viewing your powerful "Cloud Desktop" using &lt;a class="reference external" href="https://www.nomachine.com/"&gt;nomachine&lt;/a&gt;.
Apparently, that's the best way I could setup remote graphic viewing.&lt;/p&gt;
&lt;ol class="arabic simple" start="5"&gt;
&lt;li&gt;Clone the &lt;a class="reference external" href="https://github.com/kuz/DeepMind-Atari-Deep-Q-Learner"&gt;DeepMind-Atari-Deep-Q-Learner&lt;/a&gt; code.&lt;/li&gt;
&lt;li&gt;Install the dependencies.&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="literal-block"&gt;
./install_dependencies.sh
&lt;/pre&gt;
&lt;ol class="arabic simple" start="7"&gt;
&lt;li&gt;And, as my son will say. &lt;em&gt;Here you go!&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="literal-block"&gt;
./run_gpu breakout
&lt;/pre&gt;
&lt;p&gt;You can exit nomachine with the program running, and constantly come
back to monitor your computer trying to learn to play a game by itself.&lt;/p&gt;&lt;/div&gt;</description><category>computer science</category><category>research</category><guid>http://www.xtoinfinity.com/posts/deep-learner-playing-breakout.html</guid><pubDate>Wed, 25 Jan 2017 05:36:55 GMT</pubDate></item><item><title>Dominant Resource Fairness</title><link>http://www.xtoinfinity.com/posts/dominant-resource-fairness.html</link><dc:creator>Senthil Kumaran</dc:creator><description>&lt;div&gt;&lt;p&gt;I was reading the paper on &lt;a class="reference external" href="https://people.eecs.berkeley.edu/~alig/papers/drf.pdf"&gt;Dominant Resource Fairness&lt;/a&gt; and found it approachable, interesting and fairly easy to
understand.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://people.eecs.berkeley.edu/~alig/papers/drf.pdf"&gt;Dominant Resource Fairness&lt;/a&gt; is a resource allocation strategy used by a system like &lt;a class="reference external" href="http://mesos.apache.org/"&gt;Mesos&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In general terms, resources are basically things that a group will need and the idea is the allocate the resources
amongst the members of the group in an efficient way. Examples could be the amount of money (resource) to be
distributed across a group of people in the community or the processor cores in a multi-core processor that needs to be
distributed and allocated to the process running on that processor.&lt;/p&gt;
&lt;p&gt;The Dominant Resource Fairness uses &lt;a class="reference external" href="https://en.wikipedia.org/wiki/Linear_programming"&gt;Linear Programming&lt;/a&gt; technique to solve the problem of resource sharing.&lt;/p&gt;
&lt;p&gt;In a datacenter with multiple computers, having multiple CPUs, multiple memories, network cards and many other resources,
those needs to be shared across the processes that are running in the datacenter. DRF uses the concept of a dominant
resource. The Dominant share is the maximum share that an entity (process) has been allocated for any resource. For
e.g, if if a process A has heavy CPU usage and process B has heavy memory usage, the dominant resource for process A is
CPU and the dominant resource for process B is Memory.&lt;/p&gt;
&lt;p&gt;Dominant Resource Fairness seeks to maximize the minimum dominant share across all entities. That's the formulation
for the linear programming problem for you. Doing it across in a distributed way for different tasks with different
requirements is the challenge that is being solved.&lt;/p&gt;
&lt;p&gt;For example, if user A runs CPU-heavy tasks and user B runs memory-heavy tasks, the DRF attempts to equalize CPU share
of user A with the memory share of user B. In this case, the DRF would allocate more CPU and less memory to the tasks
run by user A, and allocate less CPU and more memory to the tasks run by user B. In the single resource case -- where
all jobs are requesting the same resources -- the DRF reduces to max-min fairness for that resource.&lt;/p&gt;
&lt;p&gt;Some interesting anecdotes I found in the paper include, enforcing "fairness" in resource sharing is a difficult
problem by itself.&lt;/p&gt;
&lt;blockquote&gt;
A big search company provided dedicated machines for jobs only if the users could guarantee high utilization. The
company soon found that users would sprinkle their code with infinite loops to artificially inflate utilization
levels.&lt;/blockquote&gt;
&lt;p&gt;The paper also quoted economic research on difficultly in ensuring fairness.&lt;/p&gt;
&lt;blockquote&gt;
Competitive equilibrium from equal incomes (CEEI), a popular fair allocation policy preferred in the micro-economic
domain is not strategy proof.&lt;/blockquote&gt;&lt;/div&gt;</description><category>computer science</category><category>papers</category><category>research</category><guid>http://www.xtoinfinity.com/posts/dominant-resource-fairness.html</guid><pubDate>Thu, 05 Jan 2017 03:27:53 GMT</pubDate></item></channel></rss>