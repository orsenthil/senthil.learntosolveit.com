<h1>Practical: A Simple Database</h1>
<ul>
<li>In this chapter you'll write a simple database for keeping track of CDs.</li>
<li>Common Lisp provides three distinct kinds of operators: functions, macros, and special operators.</li>
</ul>
<h2>CDs and Records</h2>
<ul>
<li>To keep track of CDs that need to be ripped to 
        <span class="wikipedia_tooltip"><a href="https://en.wikipedia.org/wiki/MP3" target="_blank">MP3</a>
            <span class="wikipedia_summary">
            <a href="https://en.wikipedia.org/wiki/MP3" target="_blank" class="wikipedia_wordmark">
              <img src="https://upload.wikimedia.org/wikipedia/commons/b/bb/Wikipedia_wordmark.svg">
              <span class="wikipedia_icon"></span>
            </a>
            MP3 (formally MPEG-1 Audio Layer III or MPEG-2 Audio Layer III) is an audio coding format developed largely by the Fraunhofer Society in Germany under the lead of Karlheinz Brandenburg. It was designed to greatly reduce the amount of data required to represent audio, yet still sound like a faithful reproduction of the original uncompressed audio to most listeners; for example, compared to CD-quality digital audio, MP3 compression can commonly achieve a 75â€“95% reduction in size, depending on the bit rate. In popular usage, MP3 often refers to files of sound or music recordings stored in the MP3 file format (.mp3) on consumer electronic devices.
            </span>
        </span>s and which CDs should be ripped first, each record in the database will contain the title and artist of the CD, a rating of how much the user likes it, and a flag saying whether it has been ripped.</li>
<li>We need a way to represent a single database record.</li>
<li>User defined class - 
        <span class="wikipedia_tooltip"><a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System" target="_blank">Common Lisp Object System</a>
            <span class="wikipedia_summary">
            <a href="https://en.wikipedia.org/wiki/Common_Lisp_Object_System" target="_blank" class="wikipedia_wordmark">
              <img src="https://upload.wikimedia.org/wikipedia/commons/b/bb/Wikipedia_wordmark.svg">
              <span class="wikipedia_icon"></span>
            </a>
            The Common Lisp Object System (CLOS) is the facility for object-oriented programming in ANSI Common Lisp. CLOS is a dynamic object system which differs radically from the OOP facilities found in more static languages such as C++ or Java. CLOS was inspired by earlier Lisp object systems such as MIT Flavors and CommonLoops, although it is more general than either. Originally proposed as an add-on, CLOS was adopted as part of the ANSI standard for Common Lisp and has been adapted into other Lisp dialects such as EuLisp or Emacs Lisp.
            </span>
        </span></li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
</pre></div>

<ul>
<li>A plist is a list where every other element, starting with the first, is a symbol that describes what the next element in the list is. Symbol can be thought of as a name.</li>
<li>For the symbols that name the fields in the CD database, you can use a particular kind of symbol, called a keyword symbol.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="ss">:A</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:B</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:C</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
</pre></div>

<ul>
<li>Function GETF, which takes a plist and a symbol and returns the value in the plist following the symbol.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="ss">:c</span><span class="p">)</span>
<span class="mi">3</span>
</pre></div>

<ul>
<li><code>make-cd</code> that will take the four fields as arguments and return a plist representing that CD.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">make-cd</span><span class="p">(</span><span class="nv">title</span><span class="w"> </span><span class="nv">artist</span><span class="w"> </span><span class="nv">rating</span><span class="w"> </span><span class="nv">ripped</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="ss">:title</span><span class="w"> </span><span class="nv">title</span><span class="w"> </span><span class="ss">:artist</span><span class="w"> </span><span class="nv">artist</span><span class="w"> </span><span class="ss">:rating</span><span class="w"> </span><span class="nv">rating</span><span class="w"> </span><span class="ss">:ripped</span><span class="w"> </span><span class="nv">ripped</span><span class="p">))</span>
<span class="nv">MAKE-CD</span>
</pre></div>

<ul>
<li>DEFUN tells us that this form is defining a new function.</li>
<li>When make-cd is called, the arguments passed to the call will be bound to the variables in the parameter list. For instance, to make a record for the CD Roses by Kathy Mattea, you might call make-cd like this:</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">make-cd</span><span class="w"> </span><span class="s">&quot;Roses&quot;</span><span class="w"> </span><span class="s">&quot;Kathy Mattea&quot;</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
<span class="p">(</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Roses&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Kathy Mattea&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
</pre></div>

<!--more Read the Notes further...-->

<h2>Filling CDs</h2>
<ul>
<li>Larger Constructs to hold records.</li>
<li>Also for simplicity you can use a global variable, <em>db</em>, which you can define with the DEFVAR macro. The asterisks (*) in the name are a Lisp naming convention for global variables.</li>
<li>You can use the PUSH macro to add items to <em>db</em>. But it's probably a good idea to abstract things a tiny bit, so you should define a function add-record that adds a record to the database.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">add-record</span><span class="w"> </span><span class="p">(</span><span class="nv">cd</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">push</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="vg">*db*</span><span class="p">))</span>
<span class="nv">ADD-RECORD</span>
</pre></div>

<ul>
<li>add-record and make-cd together to add CDs to the database.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">add-record</span><span class="w"> </span><span class="p">(</span><span class="nv">make-cd</span><span class="w"> </span><span class="s">&quot;Fly&quot;</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="no">t</span><span class="p">))</span>
<span class="p">((</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Fly&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">))</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">add-record</span><span class="w"> </span><span class="p">(</span><span class="nv">make-cd</span><span class="w"> </span><span class="s">&quot;Roses&quot;</span><span class="w"> </span><span class="s">&quot;Kathy Mattea&quot;</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="no">t</span><span class="p">))</span>
<span class="p">((</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Roses&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Kathy Mattea&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="w"> </span><span class="p">(</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Fly&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">))</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">add-record</span><span class="w"> </span><span class="p">(</span><span class="nv">make-cd</span><span class="w"> </span><span class="s">&quot;Home&quot;</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="no">t</span><span class="p">))</span>
<span class="p">((</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Home&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="w"> </span><span class="p">(</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Roses&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Kathy Mattea&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="w"> </span><span class="p">(</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Fly&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">))</span>
</pre></div>

<ul>
<li>Current value of <em>db</em> by typing <em>db</em></li>
<li>dump-db function that dumps out the database in a more human-readable format.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">dump-db</span><span class="p">()</span>
<span class="w">       </span><span class="p">(</span><span class="nb">dolist</span><span class="w"> </span><span class="p">(</span><span class="nv">cd</span><span class="w"> </span><span class="vg">*db*</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~{~a:~10t~a~%~}~%&quot;</span><span class="w"> </span><span class="nv">cd</span><span class="p">)))</span>
<span class="nv">DUMP-DB</span>
</pre></div>

<ul>
<li>Looping over all the elements of <em>db</em> with the DOLIST macro, binding each element to the variable cd in turn. For each value of cd, you use the FORMAT function to print it.</li>
<li>In format, t is shorthand for the stream <em>standard-output</em>.</li>
<li>Format directives start with ~ (much the way printf's directives start with %).</li>
</ul>
<hr>
<p>One of the coolest FORMAT directives is the ~R directive. Ever want to know how to say a really big number in English words? Lisp knows.</p>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="s">&quot;~R&quot;</span><span class="w"> </span><span class="mi">42424242424242424242424242424242424242424242424242</span><span class="p">)</span>
<span class="s">&quot;forty-two quindecillion, four hundred and twenty-four quattuordecillion, two hundred and forty-two tredecillion, four hundred and twenty-four duodecillion, two hundred and forty-two undecillion, four hundred and twenty-four decillion, two hundred and forty-two nonillion, four hundred and twenty-four octillion, two hundred and forty-two septillion, four hundred and twenty-four sextillion, two hundred and forty-two quintillion, four hundred and twenty-four quadrillion, two hundred and forty-two trillion, four hundred and twenty-four billion, two hundred and forty-two million, four hundred and twenty-four thousand, two hundred and forty-two&quot;</span>
</pre></div>

<hr>
<ul>
<li>~a directive is the aesthetic directive; it means to consume one argument and output it in a human-readable form. This will render keywords without the leading : and strings without quotation marks.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~a&quot;</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="p">)</span>
<span class="nv">Dixie</span><span class="w"> </span><span class="nv">Chicks</span>
<span class="no">NIL</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~a&quot;</span><span class="w"> </span><span class="ss">:title</span><span class="p">)</span>
<span class="nv">TITLE</span>
<span class="no">NIL</span>
</pre></div>

<ul>
<li>The ~t directive is for tabulating. The ~10t tells FORMAT to emit enough spaces to move to the tenth column before processing the next ~a. A ~t doesn't consume any arguments.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~a:~10t~a&quot;</span><span class="w"> </span><span class="ss">:artist</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="p">)</span>
<span class="nv">ARTIST:</span><span class="w">   </span><span class="nv">Dixie</span><span class="w"> </span><span class="nv">Chicks</span>
<span class="no">NIL</span>
</pre></div>

<ul>
<li>When FORMAT sees ~{ the next argument to be consumed must be a list. FORMAT loops over that list, processing the directives between the ~{ and ~}.</li>
<li>The ~% directive doesn't consume any arguments but tells FORMAT to emit a newline.</li>
<li>We could have removed dolist macro call and used the format directive itself:</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">dump-db</span><span class="p">()</span>
<span class="w">       </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="s">&quot;~{~{~a:~10t~a~%~}~%~}&quot;</span><span class="w"> </span><span class="vg">*db*</span><span class="p">))</span>
<span class="nv">DUMP-DB</span>
</pre></div>

<h2>Improving User Interaction</h2>
<ul>
<li>Need some way to prompt the user for a piece of information and read it.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">prompt-read</span><span class="p">(</span><span class="nv">prompt</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">format</span><span class="w"> </span><span class="vg">*query-io*</span><span class="w"> </span><span class="s">&quot;~a: &quot;</span><span class="w"> </span><span class="nv">prompt</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">force-output</span><span class="w"> </span><span class="vg">*query-io*</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">read-line</span><span class="w"> </span><span class="vg">*query-io*</span><span class="p">))</span>
<span class="nv">PROMPT-READ</span>
</pre></div>

<ul>
<li>Format to emit the prompt.</li>
<li>FORCE-OUTPUT is necessary in some implementations to ensure that Lisp doesn't wait for a newline.</li>
<li>Read a single line of text with the aptly named READ-LINE function.</li>
<li>query-io is a global variable, can be recognized by the <em>query-io</em> naming.</li>
</ul>
<p>Combining make-cd with prompt-read:</p>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">prompt-for-cd</span><span class="p">()</span>
<span class="w">       </span><span class="p">(</span><span class="nv">make-cd</span>
<span class="w">        </span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Title&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Artist&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Rating&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Ripped [y/n]&quot;</span><span class="p">)))</span>
<span class="nv">PROMPT-FOR-CD</span>
</pre></div>

<ul>
<li>prompt-read returns a string, for converting the value to integer, lets use lisp's parse-integer function.</li>
<li>parse-integer takes an optional argument :junk-allowed which tells to relax the conversion, if there is any exception.</li>
<li>junk-allowed returns nil, if that cannot find the integer, to get over and set it as 0, we use the or macro.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">parse-integer</span><span class="w"> </span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Rating&quot;</span><span class="p">))</span>
<span class="nv">Rating:</span><span class="w"> </span><span class="mi">10</span>

<span class="mi">10</span>
<span class="mi">2</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">parse-integer</span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Rating&quot;</span><span class="p">)</span><span class="ss">:junk-allowed</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
<span class="nv">Rating:</span><span class="w"> </span><span class="mi">10</span>

<span class="mi">10</span>
<span class="mi">2</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">parse-integer</span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Rating&quot;</span><span class="p">)</span><span class="ss">:junk-allowed</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
<span class="nv">Rating:</span><span class="w"> </span><span class="nv">Senthil</span>

<span class="no">NIL</span>
<span class="mi">0</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="p">(</span><span class="nb">parse-integer</span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Rating&quot;</span><span class="p">)</span><span class="ss">:junk-allowed</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
<span class="nv">Rating:</span><span class="w"> </span><span class="nv">Senthil</span>

<span class="mi">0</span>
</pre></div>

<ul>
<li>For y or n prompt, we can use common lisp function Y-OR-N-P, that will reprompt the user till something starting with Y, y, N, n is entered.</li>
</ul>
<p>So, the final prompt-for-cd will be:</p>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">prompt-for-cd</span><span class="w"> </span><span class="p">()</span>
<span class="w">       </span><span class="p">(</span><span class="nv">make-cd</span>
<span class="w">        </span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Title&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Artist&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="p">(</span><span class="nb">parse-integer</span><span class="w"> </span><span class="p">(</span><span class="nv">prompt-read</span><span class="w"> </span><span class="s">&quot;Rating&quot;</span><span class="p">)</span><span class="ss">:junk-allowd</span><span class="w"> </span><span class="no">t</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
<span class="w">        </span><span class="p">(</span><span class="nb">y-or-n-p</span><span class="w"> </span><span class="s">&quot;Ripped [y/n]&quot;</span><span class="p">)))</span>
<span class="nv">PROMPT-FOR-CD</span>
</pre></div>

<ul>
<li>Let's go for adding a bunch of CDs.</li>
<li>You can use the simple form of the LOOP macro, which repeatedly executes a body of expressions until it's exited by a call to RETURN.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">add-cds</span><span class="p">()</span>
<span class="w">       </span><span class="p">(</span><span class="nb">loop</span><span class="w"> </span><span class="p">(</span><span class="nv">add-record</span><span class="w"> </span><span class="p">(</span><span class="nv">prompt-for-cd</span><span class="p">))</span>
<span class="w">         </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">not</span><span class="w"> </span><span class="p">(</span><span class="nb">y-or-n-p</span><span class="w"> </span><span class="s">&quot;Another? [y/n]&quot;</span><span class="p">))(</span><span class="nb">return</span><span class="p">))))</span>
<span class="nv">ADD-CDS</span>
</pre></div>

<h2>Saving and Loading the Database</h2>
<ul>
<li>save-db function that takes a filename as an argument and saves the current state of the database.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">save-db</span><span class="w"> </span><span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">with-open-file</span><span class="w"> </span><span class="p">(</span><span class="nv">out</span><span class="w"> </span><span class="nv">filename</span>
<span class="w">                </span><span class="ss">:direction</span><span class="w"> </span><span class="ss">:output</span>
<span class="w">                </span><span class="ss">:if-exists</span><span class="w"> </span><span class="ss">:supersede</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nb">with-standard-io-syntax</span>
<span class="w">           </span><span class="p">(</span><span class="nb">print</span><span class="w"> </span><span class="vg">*db*</span><span class="w"> </span><span class="nv">out</span><span class="p">))))</span>
<span class="nv">SAVE-DB</span>
</pre></div>

<ul>
<li>WITH-OPEN-FILE macro opens a file, binds the stream to a variable, executes a set of expressions, and then closes the file. The list following WITH-OPEN-FILE is not function, but list of parameters to WITH-OPEN-FILE, defines the file to open to out stream, direction, output and if the file exists, then supersede.</li>
<li>After opening the file, we need to print the content using print command, which is different from format, it prints in lisp recognizable objects which be read back by lisp-reader.</li>
<li>WITH-STANDARD-IO-SYNTAX ensures that certain variables that affect the behavior of PRINT are set to their standard values.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">save-db</span><span class="w"> </span><span class="s">&quot;~/my-cds.db&quot;</span><span class="p">)</span>
</pre></div>

<p>If open my-cds.db, we will find the output as in <em>db</em> at CL-USER&gt; prompt.</p>
<p>The function to load the database back is similar.</p>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">load-db</span><span class="p">(</span><span class="nv">filename</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">with-open-file</span><span class="w"> </span><span class="p">(</span><span class="nv">in</span><span class="w"> </span><span class="nv">filename</span><span class="p">)</span>
<span class="w">         </span><span class="p">(</span><span class="nb">with-standard-io-syntax</span>
<span class="w">           </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="vg">*db*</span><span class="w"> </span><span class="p">(</span><span class="nb">read</span><span class="w"> </span><span class="nv">in</span><span class="p">)))))</span>
<span class="nv">LOAD-DB</span>
</pre></div>

<ul>
<li>The SETF macro is Common Lisp's main assignment operator. It sets its first argument to the result of evaluating its second argument.</li>
</ul>
<h2>Querying the Database</h2>
<ul>
<li>Query database.</li>
<li>Something LIKE <code>(select :artist "Dixie Chicks")</code></li>
<li>REMOVE-IF-NOT takes a predicate and a list and returns a copy of the list, containing only the elements that satisfy the predicate.</li>
<li>The predicate argument can be any function that accepts a single argument and returns a boolean value--NIL for false and anything else for true.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">remove-if-not</span><span class="w"> </span><span class="nf">#&#39;</span><span class="nb">evenp</span><span class="w"> </span><span class="o">&#39;</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
</pre></div>

<ul>
<li>The funny notation #' is shorthand for "Get me the function with the following name." Without the #', Lisp would treat evenp as the name of a variable and look up the value of the variable, not the function.</li>
<li>We can also pass, remove-if-not, an anonymous function.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">remove-if-not</span><span class="w"> </span><span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">x</span><span class="p">)(</span><span class="nb">=</span><span class="w"> </span><span class="mi">0</span><span class="p">(</span><span class="nb">mod</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="mi">2</span><span class="p">)))</span><span class="o">&#39;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="p">))</span>
<span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span>
</pre></div>

<ul>
<li>The anonymous function here is <code>(lambda (x) (=0 (mod x 2)))</code> which returns true when x is even, else false.</li>
<li>Note that lambda isn't the name of the function--it's the indicator you're defining an anonymous function.</li>
<li>To select record using artist, we use the property of plist, getf, and equal to compare and put them all together in a lambda expression.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">remove-if-not</span>
<span class="w">      </span><span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">cd</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="ss">:artist</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="p">))</span><span class="w"> </span><span class="vg">*db*</span><span class="p">)</span>
<span class="p">((</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Home&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="w"> </span><span class="p">(</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Fly&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">))</span>
</pre></div>

<ul>
<li>To wrap the whole expression in a function.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">select-by-artist</span><span class="w"> </span><span class="p">(</span><span class="nv">artist</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">remove-if-not</span>
<span class="w">        </span><span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">cd</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="ss">:artist</span><span class="p">)</span><span class="nv">artist</span><span class="p">))</span><span class="w"> </span><span class="vg">*db*</span><span class="p">))</span>
<span class="nv">SELECT-BY-ARTIST</span>
</pre></div>

<ul>
<li>Anonymous functions embed the required details like artist.</li>
<li>More general select function, with Anonymous function at the next stage.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">select</span><span class="w"> </span><span class="p">(</span><span class="nv">selector-fn</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="nb">remove-if-not</span><span class="w"> </span><span class="nv">selector-fn</span><span class="w"> </span><span class="vg">*db*</span><span class="p">))</span>
<span class="nv">SELECT</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">select</span><span class="w"> </span><span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">cd</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="ss">:artist</span><span class="p">)</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="p">)))</span>
<span class="p">((</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Home&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="w"> </span><span class="p">(</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Fly&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">))</span>
</pre></div>

<ul>
<li>Anonymous function creation can be wrapped up.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">artist-selector</span><span class="w"> </span><span class="p">(</span><span class="nv">artist</span><span class="p">)</span>
<span class="w">       </span><span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">cd</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="ss">:artist</span><span class="p">)</span><span class="w"> </span><span class="nv">artist</span><span class="p">)))</span>
<span class="nv">ARTIST-SELECTOR</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">select</span><span class="w"> </span><span class="p">(</span><span class="nv">artist-selector</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="p">))</span>
<span class="p">((</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Home&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="w"> </span><span class="p">(</span><span class="ss">:TITLE</span><span class="w"> </span><span class="s">&quot;Fly&quot;</span><span class="w"> </span><span class="ss">:ARTIST</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="w"> </span><span class="ss">:RATING</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="ss">:RIPPED</span><span class="w"> </span><span class="no">T</span><span class="p">))</span>
</pre></div>

<ul>
<li>Write a general purpose, selector function generator, a function that, depending upon what arguments is getting passed, will generate a selector function for different fields, or different combination of fields.</li>
<li>Keyword parameters</li>
<li>Write functions with varying number of parameters, which are bound to the corresponding arguments to the call to the function.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">foo</span><span class="w"> </span><span class="p">(</span><span class="k">&amp;key</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="nv">c</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="nv">c</span><span class="p">))</span>
</pre></div>

<p>The only difference is the &amp;key at the beginning of the argument list. However, the calls to this new foo will look quite different. These are all legal calls with the result to the right of the ==&gt;:</p>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="nv">foo</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">  </span><span class="nv">==&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nv">foo</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="nv">==&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nv">foo</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">       </span><span class="nv">==&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="no">NIL</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span>
<span class="p">(</span><span class="nv">foo</span><span class="p">)</span><span class="w">                 </span><span class="nv">==&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">NIL</span><span class="w"> </span><span class="no">NIL</span><span class="w"> </span><span class="no">NIL</span><span class="p">)</span>
</pre></div>

<ul>
<li>Need to differentiate between NIL assigned when no value passed vs explicitly assigned NIL.</li>
<li>To allow this, when you specify a keyword parameter you can replace the simple name with a list consisting of the name of the parameter, a default value, and another parameter name, called a supplied-p parameter.</li>
<li>Supplied-p parameter will set to true or false if an argument was passed to the function call.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">foo</span><span class="w"> </span><span class="p">(</span><span class="k">&amp;key</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="p">(</span><span class="nv">b</span><span class="w"> </span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nv">c</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="nv">c-p</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">list</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="nv">c</span><span class="w"> </span><span class="nv">c-p</span><span class="p">))</span>
</pre></div>

<p>Now the same calls from earlier yield these results:</p>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="nv">foo</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">  </span><span class="nv">==&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="p">(</span><span class="nv">foo</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="ss">:b</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">  </span><span class="nv">==&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="p">(</span><span class="nv">foo</span><span class="w"> </span><span class="ss">:a</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">:c</span><span class="w"> </span><span class="mi">3</span><span class="p">)</span><span class="w">       </span><span class="nv">==&gt;</span><span class="w"> </span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="no">T</span><span class="p">)</span>
<span class="p">(</span><span class="nv">foo</span><span class="p">)</span><span class="w">                 </span><span class="nv">==&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">NIL</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="mi">30</span><span class="w"> </span><span class="no">NIL</span><span class="p">)</span>
</pre></div>

<ul>
<li>A general selector function, based on the above discussions will be:</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">where</span><span class="w"> </span><span class="p">(</span><span class="k">&amp;key</span><span class="w"> </span><span class="nv">title</span><span class="w"> </span><span class="nv">artist</span><span class="w"> </span><span class="nv">rating</span><span class="w"> </span><span class="p">(</span><span class="nv">ripped</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="nv">ripped-p</span><span class="p">))</span>
<span class="w">  </span><span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">cd</span><span class="p">)</span>
<span class="w">      </span><span class="p">(</span><span class="nb">and</span>
<span class="w">       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">title</span><span class="w">    </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="ss">:title</span><span class="p">)</span><span class="w">  </span><span class="nv">title</span><span class="p">)</span><span class="w">  </span><span class="no">t</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">artist</span><span class="w">   </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="ss">:artist</span><span class="p">)</span><span class="w"> </span><span class="nv">artist</span><span class="p">)</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">rating</span><span class="w">   </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="ss">:rating</span><span class="p">)</span><span class="w"> </span><span class="nv">rating</span><span class="p">)</span><span class="w"> </span><span class="no">t</span><span class="p">)</span>
<span class="w">       </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">ripped-p</span><span class="w"> </span><span class="p">(</span><span class="nb">equal</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">cd</span><span class="w"> </span><span class="ss">:ripped</span><span class="p">)</span><span class="w"> </span><span class="nv">ripped</span><span class="p">)</span><span class="w"> </span><span class="no">t</span><span class="p">))))</span>
</pre></div>

<ul>
<li>Updating Existing Records--Another Use for WHERE</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">update</span><span class="w"> </span><span class="p">(</span><span class="nv">selector-fn</span><span class="w"> </span><span class="k">&amp;key</span><span class="w"> </span><span class="nv">title</span><span class="w"> </span><span class="nv">artist</span><span class="w"> </span><span class="nv">rating</span><span class="w"> </span><span class="p">(</span><span class="nv">ripped</span><span class="w"> </span><span class="no">nil</span><span class="w"> </span><span class="nv">ripped-p</span><span class="p">))</span>
<span class="w">  </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="vg">*db*</span>
<span class="w">        </span><span class="p">(</span><span class="nb">mapcar</span>
<span class="w">         </span><span class="nf">#&#39;</span><span class="p">(</span><span class="k">lambda</span><span class="w"> </span><span class="p">(</span><span class="nv">row</span><span class="p">)</span>
<span class="w">             </span><span class="p">(</span><span class="nb">when</span><span class="w"> </span><span class="p">(</span><span class="nb">funcall</span><span class="w"> </span><span class="nv">selector-fn</span><span class="w"> </span><span class="nv">row</span><span class="p">)</span>
<span class="w">               </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">title</span><span class="w">    </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="ss">:title</span><span class="p">)</span><span class="w"> </span><span class="nv">title</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">artist</span><span class="w">   </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="ss">:artist</span><span class="p">)</span><span class="w"> </span><span class="nv">artist</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">rating</span><span class="w">   </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="ss">:rating</span><span class="p">)</span><span class="w"> </span><span class="nv">rating</span><span class="p">))</span>
<span class="w">               </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nv">ripped-p</span><span class="w"> </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="p">(</span><span class="nb">getf</span><span class="w"> </span><span class="nv">row</span><span class="w"> </span><span class="ss">:ripped</span><span class="p">)</span><span class="w"> </span><span class="nv">ripped</span><span class="p">)))</span>
<span class="w">             </span><span class="nv">row</span><span class="p">)</span><span class="w"> </span><span class="vg">*db*</span><span class="p">)))</span>
</pre></div>

<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">update</span><span class="w"> </span><span class="p">(</span><span class="nv">where</span><span class="w"> </span><span class="ss">:artist</span><span class="w"> </span><span class="s">&quot;Dixie Chicks&quot;</span><span class="p">)</span><span class="w"> </span><span class="ss">:rating</span><span class="w"> </span><span class="mi">11</span><span class="p">)</span>
<span class="no">NIL</span>
</pre></div>

<ul>
<li>Function to delete rows.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="p">(</span><span class="nb">defun</span><span class="w"> </span><span class="nv">delete-rows</span><span class="w"> </span><span class="p">(</span><span class="nv">selector-fn</span><span class="p">)</span>
<span class="w">  </span><span class="p">(</span><span class="nb">setf</span><span class="w"> </span><span class="vg">*db*</span><span class="w"> </span><span class="p">(</span><span class="nb">remove-if</span><span class="w"> </span><span class="nv">selector-fn</span><span class="w"> </span><span class="vg">*db*</span><span class="p">)))</span>
</pre></div>

<ul>
<li>Remove Duplication and winning Big</li>
<li>When a Lisp expression contains a call to a macro, instead of evaluating the arguments and passing them to the function, the Lisp compiler passes the arguments, unevaluated, to the macro code, which returns a new Lisp expression that is then evaluated in place of the original macro call.</li>
<li>The main syntactic difference between a function and a macro is that you define a macro with DEFMACRO instead of DEFUN.</li>
</ul>
<div class="code"><pre class="code literal-block"><span class="nv">CL-USER&gt;</span><span class="p">(</span><span class="nb">defmacro</span><span class="w"> </span><span class="nv">backwards</span><span class="w"> </span><span class="p">(</span><span class="nv">expr</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="nv">expr</span><span class="p">))</span>
<span class="nv">CL-USER&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">backwards</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;hello, world&quot;</span><span class="w"> </span><span class="no">t</span><span class="w"> </span><span class="nb">format</span><span class="p">))</span>
<span class="nv">hello,</span><span class="w"> </span><span class="nv">world</span>
<span class="no">NIL</span>
</pre></div>

<p>When the REPL started to evaluate the backwards expression, it recognized that backwards is the name of a macro. So it left the expression ("hello, world" t format) unevaluated, which is good because it isn't a legal Lisp form. It then passed that list to the backwards code. The code in backwards passed the list to REVERSE, which returned the list (format t "hello, world").</p>